<!DOCTYPE HTML>
<html lang="en"><head><meta charset="utf-8"><title>lib/github.com/diku-dk/sorts/radix_sort</title><link href="../../../../../style.css" rel="stylesheet" type="text/css"></head><body><div id="header"><h1>lib/github.com/diku-dk/sorts/radix_sort</h1><ul id="navigation"><li><a href="../../../../../index.html">Contents</a></li><li><a href="../../../../../doc-index.html">Index</a></li></ul></div><div id="content"><nav id="filenav"><ul><li><a href="../../../../../doc/phash.html">phash</a></li></ul></nav><main><a id="abstract" href="#abstract" class="self_link"><h2>Abstract</h2></a><p>A non-comparison-based sort that sorts an array in <i>O(k n)</i> work
and <i>O(k log(n))</i> span, where <i>k</i> is the number of bits in each element.</p><p>Generally, this is the sorting function we recommend for Futhark
programs, but be careful about negative integers (use
<a href="#3983"><code>radix_sort_int</code></a>) and floating-point numbers (use
<a href="#4023"><code>radix_sort_float</code></a>).  If you need a comparison-based sort,
consider <code>merge_sort</code>.</p><a id="synopsis" href="#synopsis" class="self_link"><h2>Synopsis</h2></a><div id="overview"><div id="module"><table class="specs"><tr><td></td><td></td><td></td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="3906s"><a href="#3906">radix_sort</a></span></span></td><td class="spec_eql"> [<span id="3898">n</span>] <span id="3899">t</span> : </td><td class="spec_rhs">(<span id="3900">num_bits</span>: i32) -&gt; (<span id="3901">get_bit</span>: i32 -&gt; t -&gt; i32) -&gt; (<span id="3902">xs</span>: [n]t) -&gt; [n]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="3912s"><a href="#3912">with_indices</a></span></span></td><td class="spec_eql"> [<span id="3907">n</span>] <span id="3908">a</span> : </td><td class="spec_rhs">(<span id="3909">xs</span>: [n]a) -&gt; [n](a, i32)</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="3965s"><a href="#3965">radix_sort_by_key</a></span></span></td><td class="spec_eql"> [<span id="3949">n</span>] <span id="3950">t</span> <span id="3951">k</span> : </td><td class="spec_rhs">(<span id="3952">key</span>: t -&gt; k) -&gt; (<span id="3953">num_bits</span>: i32) -&gt; (<span id="3954">get_bit</span>: i32 -&gt; k -&gt; i32) -&gt; (<span id="3955">xs</span>: [n]t) -&gt; [n]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="3983s"><a href="#3983">radix_sort_int</a></span></span></td><td class="spec_eql"> [<span id="3966">n</span>] <span id="3967">t</span> : </td><td class="spec_rhs">(<span id="3968">num_bits</span>: i32) -&gt; (<span id="3969">get_bit</span>: i32 -&gt; t -&gt; i32) -&gt; (<span id="3970">xs</span>: [n]t) -&gt; [n]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="4000s"><a href="#4000">radix_sort_int_by_key</a></span></span></td><td class="spec_eql"> [<span id="3984">n</span>] <span id="3985">t</span> <span id="3986">k</span> : </td><td class="spec_rhs">(<span id="3987">key</span>: t -&gt; k) -&gt; (<span id="3988">num_bits</span>: i32) -&gt; (<span id="3989">get_bit</span>: i32 -&gt; k -&gt; i32) -&gt; (<span id="3990">xs</span>: [n]t) -&gt; [n]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="4023s"><a href="#4023">radix_sort_float</a></span></span></td><td class="spec_eql"> [<span id="4001">n</span>] <span id="4002">t</span> : </td><td class="spec_rhs">(<span id="4003">num_bits</span>: i32) -&gt; (<span id="4004">get_bit</span>: i32 -&gt; t -&gt; i32) -&gt; (<span id="4005">xs</span>: [n]t) -&gt; [n]t</td></tr><tr><td class="spec_lhs"><span class="keyword">val </span><span class="decl_name"><span id="4040s"><a href="#4040">radix_sort_float_by_key</a></span></span></td><td class="spec_eql"> [<span id="4024">n</span>] <span id="4025">t</span> <span id="4026">k</span> : </td><td class="spec_rhs">(<span id="4027">key</span>: t -&gt; k) -&gt; (<span id="4028">num_bits</span>: i32) -&gt; (<span id="4029">get_bit</span>: i32 -&gt; k -&gt; i32) -&gt; (<span id="4030">xs</span>: [n]t) -&gt; [n]t</td></tr></table></div></div><a id="description" href="#description" class="self_link"><h2>Description</h2></a><dl><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#3906s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="3906">radix_sort</a></span></span> [<span id="3898">n</span>] <span id="3899">t</span>: (<span id="3900">num_bits</span>: i32) -&gt; (<span id="3901">get_bit</span>: i32 -&gt; t -&gt; i32) -&gt; (<span id="3902">xs</span>: [n]t) -&gt; [n]t</dt><dd class="desc_doc"><p>The <code>num_bits</code> and <code>get_bit</code> arguments can be taken from one of
the numeric modules of module type <a href="../../../../futlib/math.html#912"><code>integral</code></a>
or <a href="../../../../futlib/math.html#1104"><code>float</code></a>, such as <a href="../../../../futlib/math.html#1722"><code>i32</code></a>
or <a href="../../../../futlib/math.html#2954"><code>f64</code></a>.  However, if you know that
the input array only uses lower-order bits (say, if all integers
are less than 100), then you can profitably pass a smaller
<code>num_bits</code> value to reduce the number of sequential iterations.</p><p><b>Warning:</b> while radix sort can be used with numbers, the bitwise
representation of of both integers and floats means that negative
numbers are sorted as <i>greater</i> than non-negative.  Negative floats
are further sorted according to their absolute value.  For example,
radix-sorting <code>[-2.0, -1.0, 0.0, 1.0, 2.0]</code> will produce <code>[0.0,
1.0, 2.0, -1.0, -2.0]</code>.  Use <a href="#3983"><code>radix_sort_int</code></a> and
<a href="#4023"><code>radix_sort_float</code></a> in the (likely) cases that this is not what
you want.</p></dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#3912s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="3912">with_indices</a></span></span> [<span id="3907">n</span>] <span id="3908">a</span>: (<span id="3909">xs</span>: [n]a) -&gt; [n](a, i32)</dt><dd class="desc_doc"></dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#3965s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="3965">radix_sort_by_key</a></span></span> [<span id="3949">n</span>] <span id="3950">t</span> <span id="3951">k</span>: (<span id="3952">key</span>: t -&gt; k) -&gt; (<span id="3953">num_bits</span>: i32) -&gt; (<span id="3954">get_bit</span>: i32 -&gt; k -&gt; i32) -&gt; (<span id="3955">xs</span>: [n]t) -&gt; [n]t</dt><dd class="desc_doc"><p>Like <code>radix_sort</code>, but sort based on key function.</p></dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#3983s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="3983">radix_sort_int</a></span></span> [<span id="3966">n</span>] <span id="3967">t</span>: (<span id="3968">num_bits</span>: i32) -&gt; (<span id="3969">get_bit</span>: i32 -&gt; t -&gt; i32) -&gt; (<span id="3970">xs</span>: [n]t) -&gt; [n]t</dt><dd class="desc_doc"><p>A thin wrapper around <a href="#3906"><code>radix_sort</code></a> that ensures negative
integers are sorted as expected.  Simply pass the usual <code>num_bits</code>
and <code>get_bit</code> definitions from e.g. <a href="../../../../futlib/math.html#1722"><code>i32</code></a>.</p></dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#4000s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="4000">radix_sort_int_by_key</a></span></span> [<span id="3984">n</span>] <span id="3985">t</span> <span id="3986">k</span>: (<span id="3987">key</span>: t -&gt; k) -&gt; (<span id="3988">num_bits</span>: i32) -&gt; (<span id="3989">get_bit</span>: i32 -&gt; k -&gt; i32) -&gt; (<span id="3990">xs</span>: [n]t) -&gt; [n]t</dt><dd class="desc_doc"><p>Like <code>radix_sort_int</code>, but sort based on key function.</p></dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#4023s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="4023">radix_sort_float</a></span></span> [<span id="4001">n</span>] <span id="4002">t</span>: (<span id="4003">num_bits</span>: i32) -&gt; (<span id="4004">get_bit</span>: i32 -&gt; t -&gt; i32) -&gt; (<span id="4005">xs</span>: [n]t) -&gt; [n]t</dt><dd class="desc_doc"><p>A thin wrapper around <a href="#3906"><code>radix_sort</code></a> that ensures floats are
sorted as expected.  Simply pass the usual <code>num_bits</code> and <code>get_bit</code>
definitions from <a href="../../../../futlib/math.html#3183"><code>f32</code></a> and
<a href="../../../../futlib/math.html#2954"><code>f64</code></a>.</p></dd></div><div class="decl_description"><dt class="desc_header"><a class="synopsis_link" href="#4040s">↑</a><span class="keyword">val </span><span class="decl_name"><span class="decl_name"><a id="4040">radix_sort_float_by_key</a></span></span> [<span id="4024">n</span>] <span id="4025">t</span> <span id="4026">k</span>: (<span id="4027">key</span>: t -&gt; k) -&gt; (<span id="4028">num_bits</span>: i32) -&gt; (<span id="4029">get_bit</span>: i32 -&gt; k -&gt; i32) -&gt; (<span id="4030">xs</span>: [n]t) -&gt; [n]t</dt><dd class="desc_doc"><p>Like <code>radix_sort_float</code>, but sort based on key function.</p></dd></div></dl><h2 id="see-also">See Also</h2><ul><li><code>merge_sort</code></li></ul></main></div><div id="footer">Generated by <a href="https://futhark.readthedocs.io/en/latest/man/futhark-doc.html">futhark-doc</a> 0.14.1</div></body></html>